<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
    <script src="./spark-md5.min.js" type="text/javascript"></script>
    <script type="text/javascript">
        // 前台逻辑
        // 本地存储一份以文件key作为key的上传记录 记录上次上传到的字节位置
        // 上传的时候这个字段会一起传递给后台
        // 如果位置和后台的文件长度一致 那么该请求会继续上传，成功返回{state:0，start:n，code：0} 写入本地存储记录位置
        // 如果位置和后台文件长度不一致，那么后台返回正确的长度，{state:0,start:n，code:0}，文件继续上传
        // 如果完成了{state:1,code:0}
        // state 1表示是上传完成 0 表示未完成


        var suffixStoreIndex = "_FILESTOREINDEX"
        function getFileMd5(file,successCallBack){
            var fileReader = new FileReader(),    
                blobSlice = File.prototype.mozSlice || File.prototype.webkitSlice || File.prototype.slice,    
                chunkSize = 2097152,    
                // read in chunks of 2MB    
                chunks = Math.ceil(file.size / chunkSize),    
                currentChunk = 0,    
                spark = new SparkMD5();    
            
            fileReader.onload = function(e) {    
                spark.appendBinary(e.target.result); // append binary string    
                currentChunk++;    
            
                if (currentChunk < chunks) {    
                    loadNext();    
                }    
                else {    
                    var file_suffix = "";
                    var nameArr = file.name.split(".");
                    if(nameArr.length>=2){
                        file_suffix = nameArr[nameArr.length-1];
                    }
                    successCallBack(spark.end()+"."+file_suffix);  
                }    
            };    
            
            function loadNext() {    
                var start = currentChunk * chunkSize,    
                    end = start + chunkSize >= file.size ? file.size : start + chunkSize;    
            
                fileReader.readAsBinaryString(blobSlice.call(file, start, end));    
            };    
            loadNext();  
        }

        function getStoreIndexKey(md5){
            return md5+suffixStoreIndex;
        }

        function readStartIndexByFileKey(fileKey){
            var v = localStorage.getItem(getStoreIndexKey(fileKey));
            if(!isNaN(v)&&v){
                return parseInt(v);
            }
            return 0;
        }

        function removeStartIndexByFileKey(fileKey){
            localStorage.removeItem(getStoreIndexKey(fileKey));
        }

        function writeStartIndexWithFileKey(fileKey,startIndex){
            //都是以后台的文件长度为准，这个记录如果和后台文件长度匹配，那么就可以减少一次请求而已
            //如果记录不准确，后台会判断返回正确的开始位置，然后继续上传
            localStorage.setItem(getStoreIndexKey(fileKey),startIndex);
        }

        function uploadSuccess(md5){
            removeStartIndexByFileKey(md5);
            setprogress(1,1);
        }



        function setprogress(start,all){
            var progress = "10%";
            if(start>0){
                progress =  Math.ceil(start*100/all)+"%";
            }
            document.getElementById("progress").innerHTML = progress;
        }

        var test_step = 0;
        var xhr = new XMLHttpRequest();
        function uploadFile(file,startIndex,_chunckSize,_md5){


            // 测试续传方法 chunckCount分成多次上传 在不走进行到某一步骤的时候return
            // 去掉下方注释 上传一部分
            // 然后注释掉下方代码 继续上传

            // if(test_step>3){
            //     alert("终止了");
            //     return;
            // }

            test_step+=1;
            

            var allSize = file.size;
            var fd = new FormData();

            var chunckBlob = null;
            if(startIndex+_chunckSize<allSize){
                chunckBlob=file.slice(startIndex,startIndex+_chunckSize);
            }else{
                chunckBlob=file.slice(startIndex);
            }

            setprogress(startIndex,allSize);

            fd.append("blob", chunckBlob);
            fd.append("file_size", allSize);
            fd.append("file_start", startIndex);
            fd.append("file_name", file.name);
            fd.append("file_md5", _md5);
            
         
            xhr.onreadystatechange = function(){
                if (xhr.readyState==4 && xhr.status==200){
                   var RJSON = JSON.parse(xhr.responseText);
                   var RFileStart = RJSON.start;
                   writeStartIndexWithFileKey(_md5,RFileStart);
                   if(RFileStart<allSize){
                       //继续上传
                       uploadFile(file,RFileStart,_chunckSize,_md5);
                   }else{
                       uploadSuccess(_md5);
                       return;
                   }
                }
            }

            // xhr.onprogress = function(evt){
            //     if (evt.lengthComputable) {
            //         var percentComplete = Math.round(evt.loaded * 100 / evt.total);
            //         document.getElementById('progress').innerHTML = percentComplete.toString() + '%';
            //       }
            //       else {
            //         document.getElementById('progress').innerHTML = 'unable to compute';
            //       }
            // }

         
            xhr.open('POST', './fileupload', true);
            xhr.send(fd);
        }

        //分片字节大小
        var chunkSize = 0;
        // 分几次上传，次数过多会报错
        var chunckCount = 1;
        function onSelect(e){
           var file = e.target.files[0];
           console.log(file)
           // 可以做策略控制 根据文件的大小决定chunckCount值，比如小于1M使用一个请求，
           chunkSize = parseInt(Math.ceil((file.size/chunckCount)));
           getFileMd5(file,function(md5){
             var startIndex = readStartIndexByFileKey(md5);
             uploadFile(file,startIndex,chunkSize,md5);
           });
        }
    </script>
</head>
<body>
    <input onchange="onSelect(event)" type='file'/>
    <div id='progress'></div>
</body>
</html>