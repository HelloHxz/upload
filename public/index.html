<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
    <script src="./spark-md5.min.js" type="text/javascript"></script>
    <script type="text/javascript">
        // 前台逻辑

        // 本地存储一份以文件key作为key的上传记录 记录上次上传到的字节位置
        // 上传的时候这个字段会一起传递给后台
        // 如果位置和后台的文件长度一致 那么该请求会继续上传，成功返回{file_size:n,code：0} 写入本地存储记录位置
        // 如果位置和后台文件长度不一致，那么后台返回正确的文件大小，{file_size:n，code:0}，文件继续上传
        // code 0表示后台无异常 1表示后台异常

        var suffixStoreIndex = "_FILESTOREINDEX"
        function getFileMd5(file,successCallBack){
            var fileReader = new FileReader(),    
                blobSlice = File.prototype.mozSlice || File.prototype.webkitSlice || File.prototype.slice,    
                chunkSize = 2097152,    
                chunks = Math.ceil(file.size / chunkSize),    
                currentChunk = 0,    
                spark = new SparkMD5();    
            
            fileReader.onload = function(e) {    
                spark.appendBinary(e.target.result); 
                currentChunk++;    
            
                if (currentChunk < chunks) {    
                    loadNext();    
                }    
                else {    
                    var file_suffix = "";
                    var nameArr = file.name.split(".");
                    if(nameArr.length >= 2){
                        file_suffix = "." + nameArr[nameArr.length-1];
                    }
                    successCallBack(spark.end()+file_suffix);  
                }    
            };    
            
            function loadNext() {    
                var start = currentChunk * chunkSize,    
                    end = start + chunkSize >= file.size ? file.size : start + chunkSize;    
            
                fileReader.readAsBinaryString(blobSlice.call(file, start, end));    
            };    
            loadNext();  
        }

        function getStoreIndexKey(md5){
            return md5+suffixStoreIndex;
        }

        function readStartIndexByFileKey(fileKey){
            var v = localStorage.getItem(getStoreIndexKey(fileKey));
            if(!isNaN(v)&&v){
                return parseInt(v);
            }
            return 0;
        }

        function removeStartIndexByFileKey(fileKey){
            localStorage.removeItem(getStoreIndexKey(fileKey));
        }

        function writeStartIndexWithFileKey(fileKey,startIndex){
            //都是以后台的文件长度为准，这个记录如果和后台文件长度匹配，那么就可以减少一次请求而已
            //如果记录不准确，后台会判断返回正确的开始位置，然后继续上传
            localStorage.setItem(getStoreIndexKey(fileKey),startIndex);
        }

        function uploadSuccess(md5){
            removeStartIndexByFileKey(md5);
            updateProgress("100%");
        }



        var test_step = 0;
      
        function _uploadFile(file,startIndex,_chunckSize,_md5){

            // 测试续传方法 chunckCount分成多次上传 在步骤进行到某一步的时候return
            // 去掉下方注释 上传一部分
            // 然后注释掉下方代码 继续上传

            // if(test_step>3){
            //     alert("终止了");
            //     return;
            // }

            test_step+=1;

            var allSize = file.size;
            var fd = new FormData();

            var chunckBlob = null;
            if(startIndex+_chunckSize<allSize){
                chunckBlob=file.slice(startIndex,startIndex+_chunckSize);
            }else{
                chunckBlob=file.slice(startIndex);
            }

            fd.append("blob", chunckBlob);
            fd.append("file_size", allSize);
            fd.append("file_start_index", startIndex);
            fd.append("file_name", file.name);
            fd.append("file_md5", _md5);
         
            xhr.open('POST', './fileupload', true);
            xhr.send(fd);
        }


        
        function updateProgress(label){
            document.getElementById('progress').innerHTML =label;
        }


        //分片字节大小
        var chunkSize = 0;
        // 提供分多次上传的功能，1 表示整段上传
        var chunckCount = 1;
        var xhr;
        var hasAlreadyUploadSize=0;

        function startUpload(md5,file){
            chunkSize = parseInt(Math.ceil((file.size/chunckCount)));
            hasAlreadyUploadSize = 0;
            xhr = null;
            xhr = new XMLHttpRequest();
            var startIndex = readStartIndexByFileKey(md5);

            function onprogressHandler (evt){
                if (evt.lengthComputable) {
                    var percentComplete = Math.round((hasAlreadyUploadSize+evt.loaded) * 100 /file.size);
                    updateProgress(percentComplete.toString()+"%")
                }else {
                    updateProgress("unable to compute")
                }
            }

            xhr.upload.addEventListener('progress', onprogressHandler, false);

            xhr.onreadystatechange = function(){
                if (xhr.readyState==4 && xhr.status==200){
                   var RJSON = JSON.parse(xhr.responseText);
                   if(RJSON.code===0){
                        var RFileSize = RJSON.file_size;
                        writeStartIndexWithFileKey(md5,RFileSize);
                        if(RFileSize<file.size){
                            //继续上传
                            if(hasAlreadyUploadSize===RFileSize){
                                // 避免死循环
                                return;
                            }
                            hasAlreadyUploadSize = RFileSize;
                            _uploadFile(file,RFileSize,chunkSize,md5);
                        }else{
                            uploadSuccess(md5);
                            return;
                        }
                   }else{
                       alert(RJSON.mes||"上传发生错误");
                   }
                  
                }
            }

            _uploadFile(file,startIndex,chunkSize,md5);
        }
        
        function onSelect(e){
           var file = e.target.files[0];
           console.log(file)
           getFileMd5(file,function(md5){
            startUpload(md5,file);
           });
        }
    </script>
</head>
<body>
    <input onchange="onSelect(event)" type='file'/>
    <div id='progress'></div>
</body>
</html>