<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
    <script type="text/javascript">
        // 前台逻辑
        // 本地存储一份以文件key作为key的上传记录 记录上次上传到的字节位置
        // 上传的时候这个字段会一起传递给后台
        // 如果位置和后台的文件长度一致 那么该请求会继续上传，成功返回{state:0，start:n，code：0} 写入本地存储记录位置
        // 如果位置和后台文件长度不一致，那么后台返回正确的长度，{state:0,start:n，code:0}，文件继续上传
        // 如果完成了{state:1,code:0}
        // state 1表示是上传完成 0 表示未完成

        function getUniqueFileKey(file){
            // 可以做md5 
            // 其实做用户隔离加lastModified和name也基本唯一
            return file.lastModified+"_"+file.name;
        }

        function readStartIndexByFileKey(fileKey){
            var v = localStorage.getItem(fileKey+"_filesize");
            if(!isNaN(v)){
                return parseInt(v);
            }
            return 0;
        }

        function writeStartIndexWithFileKey(fileKey,startIndex){
            localStorage.setItem(fileKey+"_filesize",startIndex);
        }

        function setprogress(start,all){
            var progress = "10%";
            if(start>0){
                progress =  Math.ceil(start*100/all)+"%";
            }
            document.getElementById("progress").innerHTML = progress;
        }

        var test_step = 0;
        var xhr = new XMLHttpRequest();
        function uploadFile(file,startIndex,_chunckSize,fileKey){


            // 测试续传方法
            // 去掉下方注释 上传一部分
            // 然后注释掉下方代码 继续上传

            // if(test_step>3){
            //     alert("终止了");
            //     return;
            // }

            test_step+=1;
            

            var allSize = file.size;
            var fd = new FormData();

            var chunckBlob = null;
            
            if(startIndex+_chunckSize<allSize){
                chunckBlob=file.slice(startIndex,startIndex+_chunckSize);
            }else{
                chunckBlob=file.slice(startIndex);
            }

            setprogress(startIndex,allSize);

            fd.append("blob", chunckBlob);
            fd.append("file_size", allSize);
            fd.append("file_start", startIndex);
            fd.append("file_name", file.name);
            fd.append("file_key", fileKey);
            

            xhr.onreadystatechange = function(){
                if (xhr.readyState==4 && xhr.status==200){
                   var RJSON = JSON.parse(xhr.responseText);
                   var RFileStart = RJSON.start;
                   var RStatus = RJSON.status;
                   if(RStatus===1){
                       setprogress(1,1);
                       return;
                   }
                   writeStartIndexWithFileKey(fileKey,RFileStart);
                   if(RFileStart<allSize){
                       //继续上传
                       uploadFile(file,RFileStart,_chunckSize,fileKey);
                   }else{
                       //完成,不上传
                       setprogress(1,1);
                       return;
                   }
                }
            }
         
            xhr.open('POST', './fileupload', true);
            xhr.send(fd);
        }

        var chunkSize = 18000;
        // ajax 请求上限，过多会报错
        var chunckCount = 5;
        function onSelect(e){
           var blob = e.target.files[0];
           console.log(blob)
           // 可以做策略控制 根据文件的大小决定chunckCount值，比如小于1M使用一个请求，
           chunkSize = parseInt(blob.size/chunckCount);
           var fileUniqueKey = getUniqueFileKey(blob);
           var startIndex = readStartIndexByFileKey(fileUniqueKey);
           uploadFile(blob,startIndex,chunkSize,fileUniqueKey);
        }
    </script>
</head>
<body>
    <input onchange="onSelect(event)" type='file'/>
    <div id='progress'></div>
</body>
</html>